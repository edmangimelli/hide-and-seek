<!DOCTYPE html>
<!-- Ed Mangimelli 2018 -->
<head>
	<title>Hide and Seek!</title>
	<meta charset="utf-8">
	<style>
		body {text-align: center; font-size: 15px; font-family: sans-serif; background-color: LightGreen;}
		input {width: 150px; font-size: 15px; font-family: sans-serif;}
		button {font-size: 15px; font-family: sans-serif;}
		div {margin: 0 auto;}
		table {margin: 0 auto; font-size: 250%; border-collapse: collapse;}
		.bold {font-weight: bold}
		.light {font-style: italic; font-size: 85%;}
		.occupiable {background-color: #ffccd4;}
		.unvisited {text-decoration: underline;}
	</style>
</head>
<body>
	<div id="messageArea"></div>
	<div id="forestArea"></div>
</body>
<script>

                       //R = current round, G = game (all rounds)
let messageArea = document.getElementById("messageArea"),
    forestArea = document.getElementById("forestArea"),
    amSeeker = false,  //R/
    seeker = "?",      //R/  who's the seeker
    seekerEmoji = "üëÅ", //G/  the emoji used for the seeker (seen by the hiders)
    started = false,   //G/  has the game started (has the first round started)
    go = false,        //R/  received go signal (controls whether or not move() works)
    name = "",         //G/  your name
    emoji = "?",       //G/  your emoji
    code = "",         //G/  the game you're playing in
    forest = [],       //R/   holds a copy of the forest for redrawing
    socket = new WebSocket("ws://localhost:8080/socket");


socket.onopen = function () {
	console.log("connected.");
};

socket.onmessage = function (e) {
	console.log("received message:");
	console.log(e.data);

	msg = e.data.split("\n")
	switch (msg[0]) {
	case "found": // emoji // name
		break
	case "game initialized": // code // emoji // name
		code = msg[1];
		emoji = msg[2];
		name = msg[3];
		seekerWaitingForPlayersScreen();
		break;
	case "go!":
		go = true;
		break;
	case "joined": // emoji // name
		if (started) {
			break;
		}
		addToJoinedList(msg[1], msg[2]);
		break;
	case "left": // emoji // name
		if (started) {
			break;
		}
		removeFromJoinedList(msg[1]);
		break;
	case "moved": // EMOJI // from // ROW // COL // to // ROW // COL
		let movingEmoji = msg[1],
		    fromRow = msg[3],
		    fromCol = msg[4],
		    toRow = msg[6],
		    toCol = msg[7];

		let fromCell = document.getElementById(`${fromRow} ${fromCol}`),
		    toCell = document.getElementById(`${toRow} ${toCol}`);

		fromCell.innerHTML = forest[fromRow][fromCol];

		if (amSeeker) {
			if (movingEmoji == emoji) {
				toCell.innerHTML = emoji;
			}
		} else {
			fromCell.classList.remove("occupied");
			toCell.classList.add("occupied");
			if (movingEmoji == seeker) {
				toCell.innerHTML = seekerEmoji;
			} else {
				toCell.innerHTML = movingEmoji;
			}
		}
// THIS NEEDS TO BE FIXED. SEEKER REMOVES TREES
		if (movingEmoji == emoji) {
//			if (!amSeeker) {
				for (let occ of Array.from(document.getElementsByClassName("occupiable"))) {
					occ.classList.remove("occupiable");
				}
//			}
			makeNearbyTreesOccupiable(toRow, toCol);
		}

		break
	case "name is taken":
		name = "";
		mainScreen();
		printlns(messageArea, "That name is taken. üòï", "Try a different name!");
		break
	case "no such game":
		code = "";
		enterCodeScreen();
		printlns(messageArea, "Can't find that game. üòï", "Is that the right code?");
		break
	case "seeker left; new seeker": // emoji // name
		break;
	case "setup": // seeker EMOJI // EMOJI ROW COL // EMOJI ROW COL // ... // forest // TREES_PER_ROW // TREES...
		if (amSeeker) {
			messageArea.innerHTML = `<span class="light">Find &apos;em, ${name}!</span>`;
		} else {
			messageArea.innerHTML = `<span class="light">Hide, ${name}!</span>`;
		}

		started = true;

		seeker = msg[1].split(" ")[1];

		let players = [], // grab players from msg
		    len = msg.length;
		let i = 2;
		for (; i < len; i++) {
			let words = msg[i].split(" ");	
			if (words[0] === "forest") {
				break;
			}
			players.push({emoji: words[0], row: words[1], col: words[2]});
		}

		makeForest(Number(msg[i+1]), msg[i+2]);
		let span = document.createElement("span");
		span.classList.add("light");
		span.appendChild(document.createTextNode(`Game: ${code}`));
		forestArea.appendChild(span);

		let row = -1,
		    col = -1;
		for (let p of players) { // put players on forest
			let cell = document.getElementById(`${p.row} ${p.col}`);
			if (p.emoji === emoji) {
				row = p.row;
				col = p.col;
			}

			if (amSeeker) { // seeker sees no one else
				if (p.emoji === emoji) {
					cell.innerHTML = emoji;
					makeNearbyTreesOccupiable(p.row, p.col);
				}
			} else { // hider sees everyone
				cell.classList.add("occupied");
				if (p.emoji == seeker) {
					cell.innerHTML = seekerEmoji;
				} else {
					cell.innerHTML = p.emoji;
				}
			}
		}

		if (!amSeeker) {
			makeNearbyTreesOccupiable(row, col);
		}

		sendMsg("ready to go");
		
		break;
	case "too few hiders":
		// this can be in the middle of a game
		// or when the seeker presses start
		break;
	case "too many games in session":
		messageArea.innerHTML = "";
		printlns(messageArea, "Whoa!", "The server can't handle", "any more games!", "Try again later", "or join a game.");
		break;
	case "wait for next round": // code // yourEmoji // yourName // emoji // name // ...
		code = msg[1];
		emoji = msg[2];
		name = msg[3];
		waitForScreen("You'll join at", "the next round!", "");
		addToJoinedList(...msg.slice(4,));
		break;
	case "wait for start": // code // yourEmoji // yourName // emoji // name // ...
		code = msg[1];
		emoji = msg[2];
		name = msg[3];
		waitForScreen("The seeker has not", "started the game yet.", "Hold Tight!");
		addToJoinedList(...msg.slice(4,));
		break;
	case "winner": // emoji // name
		break;
	default:
		// UNKNOWN MESSAGE
	}
};


mainScreen();

function mainScreen() {
	messageArea.innerHTML = `

	name: <input id="name" maxlength="31"><br>
	<br>
	<button id="Start New Game">Start New Game</button><br>
	<em>or</em><br>
	<button id="Join a Game">Join a Game</button><br> 
	<br>

	`;
	document.getElementById("Start New Game").addEventListener("click", newGame);
	document.getElementById("Join a Game").addEventListener("click", enterCodeScreen);
}

function newGame() {
	amSeeker = true;
	sendMsg("new game", document.getElementById("name").value);
}

function enterCodeScreen() {
	name = document.getElementById("name").value;
	messageArea.innerHTML = `

	code: <input id="code" maxlength="4"><br>
	<br>
	<button id="join">join</button><br>
	<br>

	`;
	document.getElementById("join").addEventListener("click", joinGame);
}

function joinGame() {
	sendMsg("join", document.getElementById("code").value, name);
}

function seekerWaitingForPlayersScreen() {
	messageArea.innerHTML = `

	You are the seeker!<br>
	Tell your friends to<br>
	<em class="bold">join</em> your game<br>
	using code: <span class="bold">${code}</span><br>
	<br>
	<div id="joined">
		<div>Joined:</div>
		<div id="${emoji}">${emoji} ${name} (you)</div>
	</div>
	<br>
	Once everyone has<br>
	joined click start.<br>
	<button id="start">Start</button><br>
	<br>
	People can join after<br>
	you start, but they'll<br>
	have to wait for the<br>
	current round to finish.<br>

	`;
	document.getElementById("start").addEventListener("click", start);
}

function waitForScreen() {
		messageArea.innerHTML = `

		Game <span class="bold">${code}</span>:<br>
		<br>
		${arguments[0]}<br>
		${arguments[1]}<br>
		${arguments[2]}<br>
		<br>
		<div id="joined">
		<div>Joined:</div>
		<div class="${emoji}">${emoji} ${name} (you)</div>
		</div>
		<br>

		`;
}


function start() {
	sendMsg("start");
}


function sendMsg() {
	let msg = Array.from(arguments).join("\n")
	socket.send(msg)
	console.log("message sent:")
	console.log(msg)
}

function printlns() {
	args = Array.from(arguments);
	len = args.length;
	for (let i = 1; i < len; i++) {
		arg[0].appendChild(document.createTextNode(arg[i]));
		arg[0].appendChild(document.createElement("br"));
	}
}

/*
function println() {
	let body = document.getElementsByTagName("body")[0];
	let args = Array.from(arguments)
	for (let i = 0; i < args.length; i++) {
		if (i > 0) {
			body.appendChild(document.createElement(" "));
		}
		body.appendChild(document.createTextNode(args[i]));
	}
	body.appendChild(document.createElement("br"));
}

function print() {
	let body = document.getElementsByTagName("body")[0];
	for (let text of Array.from(arguments)) {
		body.appendChild(document.createTextNode(text));
	}
}
*/

function hiderMove(event) {
	let id = event.target.id.split(" ");
	let row = Number(id[0]),
	    col = Number(id[1]);

	if (!event.target.classList.contains("occupiable")) {
		return // cannot move to empty spaces
	}

	sendMsg(`move to\n${row}\n${col}`);
}

function move(event) {
	if (!go) { return };
	if (!event.target.classList.contains("occupiable")) {
		return; // cannot move to empty spaces
	}
	id = event.target.id.split(" ");
	sendMsg(`move to\n${id[0]}\n${id[1]}`);
	return;
}

/*
function hasClass(thisClass, classes) {
	for (c of classes.split(" ")) {
		if (c === thisClass) {
			return true;
		}
	}
	return false;
}
*/

function makeNearbyTreesOccupiable(row, col) {
	row = Number(row);
	col = Number(col);

	for (let r = row-1; r <= row+1; r++) {
		for (let c = col-1; c <= col+1; c++) {
			if (r === row && c === col) { continue; }
			cell = document.getElementById(`${r} ${c}`);
			if (cell && cell.classList.contains("tree") && !cell.classList.contains("occupied")) { //seekers don't use the occupied class
				cell.classList.add("occupiable");
			}
		}
	}
}

function makeForest(treesPerRow, trees) {
	trees = Array.from(trees);

	let row = 0,
	    t = 0,
	    len = trees.length,
	    table = document.createElement("table");

	while (t < len) {
		let tr = document.createElement("tr"); // building forest html table
		let treeLine = []; // building forest array
		for (let col=0; col < treesPerRow; col++) {
			let td = document.createElement("td");
			td.id = `${row} ${col}`;
			if (trees[t] !== " ") {
				td.className += "tree";
				td.addEventListener("click", move);
				/*
				if (amSeeker) {
					td.addEventListener("click", seekerMove);
				} else {
					td.addEventListener("click", hiderMove);
				}
				*/
			}
			td.appendChild(document.createTextNode(trees[t]));
			tr.appendChild(td);
			treeLine.push(trees[t]);
			t++;
		}
		table.appendChild(tr);
		forest.push(treeLine);
		row++;
	}

	forestArea.appendChild(table);
}

function addToJoinedList(emoji, name) {
	joinedList = document.getElementById("joined");
	for (let i = 0; i < arguments.length; i+=2) {
		let e = arguments[i];
		let n = arguments[i+1];
		div = document.createElement("div");
		div.setAttribute("id", e);
		div.appendChild(document.createTextNode(`${e} ${n}`));
		joinedList.appendChild(div);
	}
}

function removeFromJoinedList(emoji) {
	document.getElementById("joined").removeChild(document.getElementById(emoji));
}

</script>

