<!DOCTYPE html>
<!-- Ed Mangimelli 2018 -->
<head>
	<title>Hide and Seek!</title>
	<meta charset="utf-8">
	<style>
		body {text-align: center; font-size: 15px; font-family: sans-serif; background-color: LightGreen;}
		input {width: 150px; font-size: 15px; font-family: sans-serif;}
		button {font-size: 15px; font-family: sans-serif;}
		div {margin: 0 auto;}
		table {margin: 0 auto; font-size: 250%; border-collapse: collapse;}
		.bold {font-weight: bold}
		.light {font-style: italic; font-size: 85%;}
		.occupiable {background-color: #ffccd4;}
		.unvisited {text-decoration: underline;}
	</style>
</head>
<body>
	<div id="topMsgArea"></div>
	<div id="forestArea"></div>
	<div id="bottomMsgArea"></div>
</body>
<script>


// client variables
let socket = new WebSocket("ws://localhost:8080/socket"),
    topMsgArea = document.getElementById("topMsgArea"),
    forestArea = document.getElementById("forestArea"),
    bottomMsgArea = document.getElementById("bottomMsgArea"),
  //seekerEmoji = "üëÅ"; 
    seekerEmoji = "üî¥";  //  the emoji used for the seeker (seen by the hiders)


// game variables (set once by either "game initialized" or "wait for..." msgs)
let code = "",   //  the game you're playing in
    emoji = "",  //  your emoji
    name = "";   //  your name


// round variables (these are set when a "setup" msg is received.)
let forest = [],      //  holds a copy of the forest for redrawing
    seeker = "",      //  who's the seeker
    amSeeker = false, //  are you the seeker
    go = false,       //  received go signal (controls whether or not move() works)
    playing = false;  //  are you in the game or are you waiting--
                      //    you could be waiting as a seeker to start the first
                      //    round, or you could be waiting for the seeker to
                      //    press start for the first round, or you could have
                      //    come in during a round and are waiting to join the
                      //    next round.


socket.onopen = function () {
	console.log("connected.");
};

socket.onmessage = function (e) {
	console.log("received message:");
	console.log(e.data);

	msg = e.data.split("\n")
	switch (msg[0]) {
	case "found": // emoji // name
		break;
	case "game initialized": // code // emoji // name
		code = msg[1];
		emoji = msg[2];
		name = msg[3];
		seekerWaitingForPlayersScreen();
		break;
	case "go!":
		go = true;
		break;
	case "joined": // emoji // name
		if (started) {
			break;
		}
		addToJoinedList(msg[1], msg[2]);
		break;
	case "left": // emoji // name
		if (started) {
			break;
		}
		removeFromJoinedList(msg[1]);
		break;
	case "moved": // EMOJI // from // ROW // COL // to // ROW // COL
		let movingEmoji = msg[1],
		    fromRow = msg[3],
		    fromCol = msg[4],
		    toRow = msg[6],
		    toCol = msg[7];

		let fromCell = document.getElementById(`${fromRow} ${fromCol}`),
		    toCell = document.getElementById(`${toRow} ${toCol}`);

		fromCell.innerHTML = forest[fromRow][fromCol];

		if (amSeeker) {
			if (movingEmoji == emoji) {
				toCell.innerHTML = emoji;
			}
		} else {
			fromCell.classList.remove("occupied");
			toCell.classList.add("occupied");
			if (movingEmoji == seeker) {
				toCell.innerHTML = seekerEmoji;
			} else {
				toCell.innerHTML = movingEmoji;
			}
		}
// THIS NEEDS TO BE FIXED. SEEKER REMOVES TREES
		if (movingEmoji == emoji) {
//			if (!amSeeker) {
				for (let occ of Array.from(document.getElementsByClassName("occupiable"))) {
					occ.classList.remove("occupiable");
				}
//			}
			makeNearbyTreesOccupiable(toRow, toCol);
		}

		break;
	case "name is taken": // name
		mainScreen();
		reportProblemWithDesiredName({reason: msg[0], str: msg[1]});
		break;
	case "no such game": // code
		bottomMsgArea.innerHTML = "";
		printlns(bottomMsgArea, "Can't find that game. üòï", "", "Is that the right code?");
		break;
	case "setup": // seeker EMOJI // forest // TREES_PER_ROW // TREES // EMOJI // NAME // ROW // COL // SCORE // ... 
		// forest, seeker, amSeeker, go, playing
		//  are set using this msg

		clearScreen();

		playing = true;
		go = false;

		seeker = msg[1].split(" ")[1];

		if (seeker === emoji) { amSeeker = true; }

		makeForest(Number(msg[3]), msg[4]);

		let topMsg = "";
		if (amSeeker) {
			topMsg = `Find &apos;em, ${name}!`;
		} else {
			topMsg = `Hide, ${name}!`;
		}
		printlns(topMsgArea, topMsg);
		printlns(bottomMsgArea, `Game: ${code}`);



		let players = [], // grab players from msg
		    len = msg.length;
		let i = 2;
		for (; i < len; i++) {
			let words = msg[i].split(" ");	
			if (words[0] === "forest") {
				break;
			}
			players.push({emoji: words[0], row: words[1], col: words[2]});
		}


		let row = -1,
		    col = -1;
		for (let p of players) { // put players on forest
			let cell = document.getElementById(`${p.row} ${p.col}`);
			if (p.emoji === emoji) {
				row = p.row;
				col = p.col;
			}

			if (amSeeker) { // seeker sees no one else
				if (p.emoji === emoji) {
					cell.innerHTML = emoji;
					makeNearbyTreesOccupiable(p.row, p.col);
				}
			} else { // hider sees everyone
				cell.classList.add("occupied");
				if (p.emoji == seeker) {
					cell.innerHTML = seekerEmoji;
				} else {
					cell.innerHTML = p.emoji;
				}
			}
		}

		if (!amSeeker) {
			makeNearbyTreesOccupiable(row, col);
		}

		sendMsg("ready to go");
		
		break;
	case "too few hiders":
		if (playing) {
			playing = false;
			seekerWaitingForPlayersScreen();
		}
		bottomMsgArea.innerHTML = "";
		printlns(bottomMsgArea, "Too few hiders! üòï", "", "Ask some people to join!");
		break;
	case "too many games in session":
		bottomMsgArea.innerHTML = "";
		printlns(bottomMsgArea, "Whoa!", "", "The server can't handle", "any more games!", "", "Try again later", "or join a game.");
		break;
	case "wait for next round": // code // yourEmoji // yourName // emoji // name // ...
		code = msg[1];
		emoji = msg[2];
		name = msg[3];
		waitForScreen("You'll join at", "the next round!", "");
		addToJoinedList(...msg.slice(4,));
		break;
	case "wait for start": // code // yourEmoji // yourName // emoji // name // ...
		code = msg[1];
		emoji = msg[2];
		name = msg[3];
		waitForScreen("The seeker has not", "started the game yet.", "Hold Tight!");
		addToJoinedList(...msg.slice(4,));
		break;
	case "winner": // emoji // name
		break;
	default:
		console.log("\n! unknown message:");
		console.log(msg);
		console.log("");
		break;
	}
};


mainScreen();

function mainScreen() {
	topMsgArea.innerHTML = `

	name: <input id="name" maxlength="31"><br>
	<br>
	<button id="Start New Game">Start New Game</button><br>
	<em>or</em><br>
	<button id="Join a Game">Join a Game</button><br> 
	<br>

	`;
	document.getElementById("Start New Game").addEventListener("click", newGame);
	document.getElementById("Join a Game").addEventListener("click", enterCodeScreen);
}

function newGame() {
	let desiredName = validName(document.getElementById("name").value);
	if (!desiredName.valid) {
		reportProblemWithDesiredName(desiredName);
		return;
	}
	sendMsg("new game", desiredName.str);
}

function enterCodeScreen() {
	let desiredName = validName(document.getElementById("name").value);
	if (!desiredName.valid) {
		reportProblemWithDesiredName(desiredName);
		return;
	}

	topMsgArea.innerHTML = `

	code: <input id="code" maxlength="4"><br>
	<br>
	<button id="join">join</button><br>
	<br>

	`;

	joinGame = function() {
		sendMsg("join", document.getElementById("code").value, desiredName.str);
	};

	document.getElementById("join").addEventListener("click", joinGame);
}

function clearScreen() {
	topMsgArea.innerHTML = "";
	forestArea.innerHTML = "";
	bottomMsgArea.innerHTML = "";
}

function seekerWaitingForPlayersScreen() {
	clearScreen();
	topMsgArea.innerHTML = `

	You are the seeker!<br>
	Tell your friends to<br>
	<em class="bold">join</em> your game<br>
	using code: <span class="bold">${code}</span><br>
	<br>
	<div id="joined">
		<div>Joined:</div>
		<div id="${emoji}">${emoji} ${name} (you)</div>
	</div>
	<br>
	Once everyone has<br>
	joined click start.<br>
	<button id="start">Start</button>

	`;

	bottomMsgArea.innerHTML = `

	<br>
	People can join after<br>
	you start, but they'll<br>
	have to wait for the<br>
	current round to finish.

	`;
	document.getElementById("start").addEventListener("click", start);
}

function waitForScreen() {
	topMsgArea.innerHTML = `

	Game <span class="bold">${code}</span>:<br>
	<br>
	${arguments[0]}<br>
	${arguments[1]}<br>
	${arguments[2] === "" ? "": arguments[2]+ "<br>"}
	<br>
	<div id="joined">
	<div>Joined:</div>
	<div class="${emoji}">${emoji} ${name} (you)</div>
	</div>
	<br>

	`;
	bottomMsgArea.innerHTML = "";
}


function start() {
	sendMsg("start");
}


function sendMsg() {
	let msg = Array.from(arguments).join("\n")
	socket.send(msg)
	console.log("message sent:")
	console.log(msg)
}

function printlns() {
	args = Array.from(arguments);
	len = args.length;
	args[0].appendChild(document.createElement("br"));
	for (let i = 1; i < len; i++) {
		if (!(args[i] === "")) {
			args[0].appendChild(document.createTextNode(args[i]));
		}
		args[0].appendChild(document.createElement("br"));
	}
}

/*
function println() {
	let body = document.getElementsByTagName("body")[0];
	let args = Array.from(arguments)
	for (let i = 0; i < args.length; i++) {
		if (i > 0) {
			body.appendChild(document.createElement(" "));
		}
		body.appendChild(document.createTextNode(args[i]));
	}
	body.appendChild(document.createElement("br"));
}

function print() {
	let body = document.getElementsByTagName("body")[0];
	for (let text of Array.from(arguments)) {
		body.appendChild(document.createTextNode(text));
	}
}
*/

function hiderMove(event) {
	let id = event.target.id.split(" ");
	let row = Number(id[0]),
	    col = Number(id[1]);

	if (!event.target.classList.contains("occupiable")) {
		return // cannot move to empty spaces
	}

	sendMsg(`move to\n${row}\n${col}`);
}

function move(event) {
	if (!go) { return };
	if (!event.target.classList.contains("occupiable")) {
		return; // cannot move to empty spaces
	}
	id = event.target.id.split(" ");
	sendMsg(`move to\n${id[0]}\n${id[1]}`);
	return;
}

/*
function hasClass(thisClass, classes) {
	for (c of classes.split(" ")) {
		if (c === thisClass) {
			return true;
		}
	}
	return false;
}
*/

function makeNearbyTreesOccupiable(row, col) {
	row = Number(row);
	col = Number(col);

	for (let r = row-1; r <= row+1; r++) {
		for (let c = col-1; c <= col+1; c++) {
			if (r === row && c === col) { continue; }
			cell = document.getElementById(`${r} ${c}`);
			if (cell && cell.classList.contains("tree") && !cell.classList.contains("occupied")) { //seekers don't use the occupied class
				cell.classList.add("occupiable");
			}
		}
	}
}

function makeForest(treesPerRow, trees) {
	trees = Array.from(trees);

	let row = 0,
	    t = 0,
	    len = trees.length,
	    table = document.createElement("table");

	while (t < len) {
		let tr = document.createElement("tr"); // building forest html table
		let treeLine = []; // building forest array
		for (let col=0; col < treesPerRow; col++) {
			let td = document.createElement("td");
			td.id = `${row} ${col}`;
			if (trees[t] !== " ") {
				td.className += "tree";
				td.addEventListener("click", move);
			}
			td.appendChild(document.createTextNode(trees[t]));
			tr.appendChild(td);
			treeLine.push(trees[t]);
			t++;
		}
		table.appendChild(tr);
		forest.push(treeLine);
		row++;
	}

	forestArea.appendChild(table);
}

function addToJoinedList(emoji, name) {
	joinedList = document.getElementById("joined");
	for (let i = 0; i < arguments.length; i+=2) {
		let e = arguments[i];
		let n = arguments[i+1];
		div = document.createElement("div");
		div.setAttribute("id", e);
		div.appendChild(document.createTextNode(`${e} ${n}`));
		joinedList.appendChild(div);
	}
}

function removeFromJoinedList(emoji) {
	document.getElementById("joined").removeChild(document.getElementById(emoji));
}

function reportProblemWithDesiredName(desiredName) {
	bottomMsgArea.innerHTML = "";
	switch (desiredName.reason) {
	case "empty string":
		printlns(bottomMsgArea, "What&apos;s your name?");
		break;
	case "illegal character":
		printlns(bottomMsgArea, "Can't use this", "character in a name:", desiredName.str, "", "Try a different name üòÑ");
		break;
	case "name is taken":
		printlns(bottomMsgArea, "This name's taken:", desiredName.str, "", "Try a different name üòÑ");
		break;
	default:
		printlns(bottomMsgArea, "Try a different name üòÑ");
		break;
	}
}

function validName(name) {
	name = String(name);
	let result = {valid: false, reason: "", str: ""}; // str either holds the valid name or an illegal character

	if (name === "") {
		result.reason = "empty string";
		return result;
	}
	
	let illChar = illegalChar(name);

	if (illChar === "") {
		result.valid = true;
		result.str = name;
		return result;
	} else {
		result.reason = "illegal character";
		result.str = illChar;
		return result;
	}
}

function illegalChar(name) {
	if (name.split("\n").length > 1) {
		return "\n";
	}

	let illChar = /[^\-\w.()[\]]/.exec(name);

	if (illChar == null) {
		return "";
	} else {
		return illChar[0];
	}
}

</script>

